import folium
import osmnx as ox
import networkx as nx
import requests
import webbrowser
import tkinter as tk
from tkinter import ttk
from tkinter import messagebox

# Función para obtener las coordenadas geográficas a partir de una dirección
def geocode_address(country, province, department, address):
    location = f"{address}, {department}, {province}, {country}"
    url = 'https://nominatim.openstreetmap.org/search'
    params = {
        'q': location,
        'format': 'json',
        'limit': 1
    }
    response = requests.get(url, params=params)
    if response.status_code == 200:
        data = response.json()
        if len(data) > 0:
            return float(data[0]['lat']), float(data[0]['lon'])
    return None

def calculate_distance(start_coord, end_coord):
    return ox.distance.great_circle_vec(start_coord[0], start_coord[1], end_coord[0], end_coord[1])

def get_directions():
    start_country = start_country_entry.get()
    start_province = start_province_entry.get()
    start_department = start_department_entry.get()
    start_address = start_address_entry.get()

    end_country = end_country_entry.get()
    end_province = end_province_entry.get()
    end_department = end_department_entry.get()
    end_address = end_address_entry.get()

    # Deshabilitar el botón de obtener direcciones
    get_directions_button.configure(state='disabled')

    # Obtener las coordenadas geográficas de las direcciones de origen y destino
    start_coord = geocode_address(start_country, start_province, start_department, start_address)
    end_coord = geocode_address(end_country, end_province, end_department, end_address)

    if start_coord is not None and end_coord is not None:
        # Calcular la distancia entre el punto de inicio y el punto de destino
        distance = calculate_distance(start_coord, end_coord)

        # Obtener el grafo de la red de calles en un área cercana al punto de inicio para conducción en auto
        graph = ox.graph_from_point((start_coord[1], start_coord[0]), dist=distance, network_type='drive', simplify=True)

        # Agregar los nodos de inicio y fin al grafo
        start_node = ox.distance.nearest_nodes(graph, start_coord[1], start_coord[0])
        end_node = ox.distance.nearest_nodes(graph, end_coord[1], end_coord[0])
        graph.add_nodes_from([(start_node, {'pos': start_coord}), (end_node, {'pos': end_coord})])

        # Encontrar el camino más corto utilizando el algoritmo Dijkstra
        path = nx.shortest_path(graph, start_node, end_node, weight='length')

        # Obtener las coordenadas de los nodos en el camino más corto
        path_coords = [(graph.nodes[node]['y'], graph.nodes[node]['x']) for node in path]

        # Crear el mapa
        map = folium.Map(location=start_coord, zoom_start=14)

        # Agregar marcadores al mapa
        folium.Marker(start_coord, popup='Start').add_to(map)
        folium.Marker(end_coord, popup='End').add_to(map)

        # Agregar la línea que representa el camino más corto al mapa
        folium.PolyLine(path_coords, color='blue', weight=2.5, opacity=1).add_to(map)

        # Mostrar el mapa
        map.save('map.html')
        webbrowser.open('map.html')

    else:
        messagebox.showerror("Error", "No se pudieron obtener las coordenadas de inicio y fin.")

    # Habilitar nuevamente el botón de obtener direcciones
    get_directions_button.configure(state='normal')

# Crear la ventana principal
window = tk.Tk()
window.title("Calculadora de Ruta")

# Crear los campos de entrada de direcciones
start_country_label = ttk.Label(window, text="País de inicio:")
start_country_label.grid(column=0, row=0, padx=10, pady=5)
start_country_entry = ttk.Entry(window)
start_country_entry.grid(column=1, row=0, padx=10, pady=5)

start_province_label = ttk.Label(window, text="Provincia de inicio:")
start_province_label.grid(column=0, row=1, padx=10, pady=5)
start_province_entry = ttk.Entry(window)
start_province_entry.grid(column=1, row=1, padx=10, pady=5)

start_department_label = ttk.Label(window, text="Departamento de inicio:")
start_department_label.grid(column=0, row=2, padx=10, pady=5)
start_department_entry = ttk.Entry(window)
start_department_entry.grid(column=1, row=2, padx=10, pady=5)

start_address_label = ttk.Label(window, text="Dirección de inicio:")
start_address_label.grid(column=0, row=3, padx=10, pady=5)
start_address_entry = ttk.Entry(window)
start_address_entry.grid(column=1, row=3, padx=10, pady=5)

end_country_label = ttk.Label(window, text="País de destino:")
end_country_label.grid(column=0, row=4, padx=10, pady=5)
end_country_entry = ttk.Entry(window)
end_country_entry.grid(column=1, row=4, padx=10, pady=5)

end_province_label = ttk.Label(window, text="Provincia de destino:")
end_province_label.grid(column=0, row=5, padx=10, pady=5)
end_province_entry = ttk.Entry(window)
end_province_entry.grid(column=1, row=5, padx=10, pady=5)

end_department_label = ttk.Label(window, text="Departamento de destino:")
end_department_label.grid(column=0, row=6, padx=10, pady=5)
end_department_entry = ttk.Entry(window)
end_department_entry.grid(column=1, row=6, padx=10, pady=5)

end_address_label = ttk.Label(window, text="Dirección de destino:")
end_address_label.grid(column=0, row=7, padx=10, pady=5)
end_address_entry = ttk.Entry(window)
end_address_entry.grid(column=1, row=7, padx=10, pady=5)

# Crear el botón de obtener direcciones
get_directions_button = ttk.Button(window, text="Obtener Direcciones", command=get_directions)
get_directions_button.grid(column=0, row=8, columnspan=2, padx=10, pady=10)

# Iniciar el bucle de la aplicación
window.mainloop()
